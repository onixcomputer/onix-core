# MicroVM Permission and OEM String Security Analysis
**Timestamp:** 2025-09-26 20:39:00
**Issue:** microvm@test-vm.service failing with "Permission denied" reading clan vars secrets

## Root Cause Analysis

### Current State
- **Service User:** `microvm` (uid=981)
- **Service Group:** `kvm` (gid=302)
- **Secret File:** `/run/secrets/vars/test-vm-secrets/api-key`
- **Secret Permissions:** `root:root 0400` (only root can read)
- **Failure:** microvm user cannot read the secret file

### Why This Fails
```bash
# Service runs as
User=microvm
Group=kvm

# Secret is owned by
root:root with mode 0400

# Result: Permission denied when microvm user tries to read
```

## Solution Architecture

### Option 1: Immediate Fix (Add Group Permissions)
**Approach:** Modify clan vars generator to allow kvm group read access

**Changes Required:**
```nix
clan.core.vars.generators.test-vm-secrets = {
  files = {
    "api-key" = {
      secret = true;
      owner = "root";
      group = "kvm";      # ADD: Allow kvm group access
      mode = "0440";      # CHANGE: Group read permission
    };
  };
};
```

**Impact:**
- ✅ Minimal code changes
- ✅ Works with existing manual runner script
- ⚠️  Secrets readable by all users in kvm group
- ⚠️  Doesn't leverage existing clan service infrastructure

### Option 2: Migrate to Clan Service Module (Recommended)
**Approach:** Use the microvm clan service module at `modules/microvm/default.nix`

**Architecture:**
```
┌─────────────────────────────────────────────────────────┐
│  HOST: britton-desktop                                  │
│                                                          │
│  clan.core.vars.generators.microvm-test-vm              │
│    ↓ (auto-generated by module)                         │
│  /run/secrets/vars/microvm-test-vm/{api-key,...}        │
│    ↓ (with correct permissions)                         │
│  modules/microvm/default.nix runtime injection          │
│    ↓ (reads secrets at VM start)                        │
│  cloud-hypervisor --platform oem_strings=[...]          │
│    ↓ (SMBIOS Type 11)                                   │
│  ┌─────────────────────────────────────────────────┐   │
│  │ GUEST: test-vm                                  │   │
│  │                                                 │   │
│  │  systemd reads SMBIOS OEM strings               │   │
│  │    ↓                                            │   │
│  │  LoadCredential=api-key:API_KEY                 │   │
│  │    ↓                                            │   │
│  │  $CREDENTIALS_DIRECTORY/api-key (ephemeral)     │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

**Benefits:**
- ✅ Uses existing, tested infrastructure
- ✅ Automatic permission handling (module sets group=kvm, mode=0440)
- ✅ Follows clan service pattern (inventory/services/*)
- ✅ Secrets only accessible by microvm service
- ✅ Leverages runtimeSecrets abstraction
- ✅ Better maintainability

## Security Analysis: OEM Strings for Secret Transmission

### Threat Model
**Trust Boundary:** Host hypervisor is trusted (not confidential computing)
- Host: NixOS britton-desktop (trusted admin control)
- Hypervisor: cloud-hypervisor (trusted, same machine)
- Guest: test-vm (controlled by same admin)

### Security Properties

#### 1. Host-Side Secret Storage
```
/run/secrets/vars/test-vm-secrets/api-key
├─ Encrypted at rest: SOPS with age
├─ Decrypted to tmpfs: /run (memory-backed)
├─ Permissions: root:kvm 0440
└─ Access: Only microvm service can read
```

#### 2. Secret Transmission (OEM Strings)
```
SMBIOS Type 11 OEM Strings
├─ Passed at VM creation time (not persistent)
├─ Format: io.systemd.credential:API_KEY=<value>
├─ Visible in: hypervisor process memory during startup
└─ Not written to disk on host
```

**Security Characteristics:**
- ⚠️  Visible in hypervisor process memory temporarily
- ⚠️  Visible in cloud-hypervisor process command line (during exec)
- ⚠️  Could be logged if cloud-hypervisor has verbose logging
- ✅  Not persistent (only exists during VM creation)
- ✅  Host process isolation via user separation
- ✅  No network exposure

#### 3. Guest-Side Credential Storage
```
systemd credentials (systemd.io/CREDENTIALS/)
├─ Storage: $CREDENTIALS_DIRECTORY (tmpfs, memory-backed)
├─ Lifecycle: Ephemeral, destroyed on service stop
├─ Permissions: Service-specific, process-isolated
└─ Format: Individual files per credential
```

**Security Properties:**
- ✅  Ephemeral (memory-only, never written to VM disk)
- ✅  Process-isolated (only accessible by service)
- ✅  Automatic cleanup on service termination
- ✅  No persistence across reboots

### Attack Vectors and Mitigations

| Attack Vector | Risk Level | Mitigation |
|--------------|-----------|------------|
| Process memory dump of cloud-hypervisor | Low | Short exposure window, host isolation |
| /proc/<pid>/cmdline inspection | Medium | systemd unit blocks unprivileged access |
| cloud-hypervisor logs | Low | Cloud-hypervisor doesn't log OEM strings |
| VM disk image extraction | None | Credentials never written to disk |
| Network sniffing | None | No network transmission |
| Guest memory dump from host | Medium | Requires root on host (trusted) |

### Confidential Computing Considerations

**Current Setup:** NOT confidential computing
- Hypervisor is trusted
- Host admin has full access
- SMBIOS OEM string approach is appropriate

**If Confidential Computing Required:**
Would need:
- AMD SEV-SNP or Intel TDX
- Encrypted credentials (SetCredentialEncrypted)
- Guest attestation before releasing secrets
- Untrusted hypervisor model

**Systemd Recommendation (from systemd/systemd#27604):**
> "For the userspace stuff (eg: credentials), perhaps we could make them
> disabled-by-default, but allow opt-in? Userspace code and configuration
> is signed or encrypted, and thus should be fine to trust to make that
> decision."

In our case, since we control the hypervisor, OEM strings are acceptable.

## Comparison: Alternative Secret Delivery Methods

### 1. OEM Strings (Current Approach)
```
Pros:
✅ Fast startup (no network round-trip)
✅ Hypervisor-agnostic (SMBIOS standard)
✅ systemd native integration
✅ Ephemeral in guest

Cons:
⚠️  Visible in hypervisor process space
⚠️  Not suitable for confidential computing
⚠️  Limited size (SMBIOS Type 11 constraints)
```

### 2. Virtio-vsock + Secret Service
```
Pros:
✅ Host-guest communication channel
✅ Can implement challenge-response
✅ Secrets never in command line

Cons:
❌ Requires custom secret service on host
❌ More complex implementation
❌ Network-like attack surface
```

### 3. Shared Filesystem + Mount
```
Pros:
✅ Simple file-based access

Cons:
❌ Persistent on disk (security risk)
❌ Complex permission management
❌ Lifecycle management issues
```

### 4. Cloud-Init / NoCloud
```
Pros:
✅ Industry standard for cloud VMs

Cons:
❌ ISO/disk-based (persistent)
❌ Designed for cloud, overkill for local
❌ More moving parts
```

## Recommendation

**For Production:**
Use **Option 2** (Clan Service Module) with OEM strings because:
1. Infrastructure already exists and is tested
2. Secrets are protected at rest (SOPS) and in transit (memory-only)
3. Ephemeral credentials in guest (systemd best practice)
4. Appropriate for trusted hypervisor environment
5. Follows established clan patterns

**Security Posture:**
- ✅ Adequate for non-confidential workloads
- ✅ Defense in depth (multiple layers)
- ✅ Minimal attack surface
- ✅ Auditability via clan vars system

**When to Reconsider:**
- Confidential computing requirements emerge
- Multi-tenant hypervisor (untrusted hypervisor)
- Regulatory compliance requiring hardware-based attestation
- Secrets that shouldn't exist in hypervisor memory even briefly

## Implementation Details

### Clan Vars Permission System

From clan-core analysis (`nixosModules/clanCore/vars/interface.nix`):

```nix
files.<name> = {
  owner = "root";        # Default: "root"
  group = "root";        # Default: "root" (or "wheel" on Darwin)
  mode = "0400";         # Default: "0400"
  secret = true;         # Triggers SOPS encryption
  deploy = true;         # Deploy to target machine
  neededFor = "services"; # systemd target dependency
};
```

**Permission Application:**
1. Generator runs: `clan vars generate --machine britton-desktop`
2. Secrets created in: `/run/secrets/vars/<generator-name>/`
3. sops-nix applies: owner, group, mode from config
4. Files are on tmpfs: `/run` (memory-backed, not persistent)

### MicroVM Module Permission Handling

The module at `modules/microvm/default.nix:374-379` automatically sets:

```nix
files = lib.mapAttrs (_name: _secret: {
  secret = true;
  deploy = true;
  mode = "0400";  # Default, should be 0440 for group read
}) secretsWithGenerators;
```

**Required Change for Module:**
```nix
files = lib.mapAttrs (_name: _secret: {
  secret = true;
  deploy = true;
  owner = "root";
  group = "kvm";   # ADD: Allow microvm service access
  mode = "0440";   # CHANGE: Enable group read
}) secretsWithGenerators;
```

## Testing Procedure

After implementing fix:
1. Regenerate secrets: `clan vars generate --machine britton-desktop`
2. Verify permissions: `ls -la /run/secrets/vars/test-vm-secrets/`
3. Restart VM: `systemctl restart microvm@test-vm`
4. Check status: `systemctl status microvm@test-vm`
5. Verify credentials in guest: `systemd-creds --system list`

## Conclusion

**Immediate Action:** Add `group = "kvm"` and `mode = "0440"` to secret files

**Long-term Strategy:** Migrate to inventory-based microvm service configuration

**Security Assessment:** OEM string approach is appropriate for trusted hypervisor environment, provides good security properties (ephemeral, process-isolated, memory-backed), and follows systemd best practices.